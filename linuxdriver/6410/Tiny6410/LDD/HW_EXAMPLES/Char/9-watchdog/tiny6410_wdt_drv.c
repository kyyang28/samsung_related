#include <linux/module.h>#include <linux/types.h>#include <linux/timer.h>#include <linux/miscdevice.h>#include <linux/watchdog.h>#include <linux/fs.h>#include <linux/init.h>#include <linux/platform_device.h>#include <linux/interrupt.h>#include <linux/clk.h>#include <linux/uaccess.h>#include <linux/io.h>#include <linux/slab.h>#include <mach/map.h>/* MOST IMPORTANT, otherwise compile error */#undef S3C_VA_WATCHDOG#define S3C_VA_WATCHDOG (0)#include <plat/regs-watchdog.h>#define CONFIG_TINY6410_WATCHDOG_TIMEOUT_DEFAULT_VALUE      10static struct resource  *wdt_mem;static struct resource  *wdt_irq;static struct clk       *wdt_clk;static void __iomem     *wdt_va;static unsigned int	    wdt_count;static int timeout_val = CONFIG_TINY6410_WATCHDOG_TIMEOUT_DEFAULT_VALUE;static char		 expect_close;static DEFINE_SPINLOCK(tiny6410_wdt_lock);static void tiny6410_wdt_feeddog(void){	spin_lock(&tiny6410_wdt_lock);	writel(wdt_count, wdt_va + S3C2410_WTCNT);	spin_unlock(&tiny6410_wdt_lock);}static irqreturn_t tiny6410_wdt_irq(int irq, void *data){    tiny6410_wdt_feeddog();    return IRQ_HANDLED;}static int tiny6410_setup_wdt_config(int timeout){    	unsigned long freq = clk_get_rate(wdt_clk);	unsigned int count;	unsigned int divisor = 1;	unsigned long wtcon;	if (timeout < 1)		return -EINVAL;	freq /= 128;	count = timeout * freq;	/* if the count is bigger than the watchdog register,	   then work out what we need to do (and if) we can	   actually make this value	*/	if (count >= 0x10000) {		for (divisor = 1; divisor <= 0x100; divisor++) {    /* 0x100 = 256 */			if ((count / divisor) < 0x10000)				break;		}		if ((count / divisor) >= 0x10000) {            printk(KERN_NOTICE"timeout %d too big\n", timeout);  			return -EINVAL;		}	}	timeout_val = timeout;	count /= divisor;	wdt_count = count;	/* update the pre-scaler */	wtcon = readl(wdt_va + S3C2410_WTCON);	wtcon &= ~S3C2410_WTCON_PRESCALE_MASK;	wtcon |= S3C2410_WTCON_PRESCALE(divisor-1);	writel(count, wdt_va + S3C2410_WTDAT);	writel(wtcon, wdt_va + S3C2410_WTCON);	return 0;}static void __tiny6410_wdt_stop(void){	unsigned long wtcon;	wtcon = readl(wdt_va + S3C2410_WTCON);	wtcon &= ~(S3C2410_WTCON_ENABLE | S3C2410_WTCON_RSTEN);	writel(wtcon, wdt_va + S3C2410_WTCON);}static void tiny6410_wdt_start(void){	unsigned long wtcon;	spin_lock(&tiny6410_wdt_lock);	__tiny6410_wdt_stop();	wtcon = readl(wdt_va + S3C2410_WTCON);	wtcon |= S3C2410_WTCON_ENABLE | S3C2410_WTCON_DIV128;	wtcon &= ~S3C2410_WTCON_INTEN;	wtcon |= S3C2410_WTCON_RSTEN;	writel(wdt_count, wdt_va + S3C2410_WTDAT);	writel(wdt_count, wdt_va + S3C2410_WTCNT);	writel(wtcon, wdt_va + S3C2410_WTCON);    	spin_unlock(&tiny6410_wdt_lock);}static void tiny6410_wdt_stop(void){	spin_lock(&tiny6410_wdt_lock);	__tiny6410_wdt_stop();	spin_unlock(&tiny6410_wdt_lock);}static int tiny6410_wdt_open(struct inode *inode, struct file *file){	expect_close = 0;    	/* start the timer */	tiny6410_wdt_start();    return 0;}static long tiny6410_wdt_ioctl(struct file *file,	unsigned int cmd,							unsigned long arg){	void __user *argp = (void __user *)arg;	int __user *p = argp;	int new_timeout_value;	switch (cmd) {	case WDIOC_KEEPALIVE:		tiny6410_wdt_feeddog();		return 0;    case WDIOC_SETTIMEOUT:		if (get_user(new_timeout_value, p))			return -EFAULT;        if (tiny6410_setup_wdt_config(new_timeout_value))			return -EINVAL;        tiny6410_wdt_feeddog();        return put_user(timeout_val, p);    case WDIOC_GETTIMEOUT:		return put_user(timeout_val, p);    default:		return -ENOTTY;	}}static int tiny6410_wdt_release(struct inode *inode, struct file *file){	/*	 *	Shut off the timer.	 * 	Lock it in if it's a module and we set nowayout	 */	if (expect_close == 42)		tiny6410_wdt_stop();	else {		printk(KERN_NOTICE"Unexpected close, not stopping watchdog\n");		tiny6410_wdt_feeddog();	}    	expect_close = 0;	return 0;}static ssize_t tiny6410_wdt_write(struct file *file, const char __user *data,				size_t len, loff_t *ppos){	/*	 *	Refresh the timer.	 */	if (len) {		size_t i;		/* In case it was set long ago */		expect_close = 0;		for (i = 0; i != len; i++) {			char c;			if (get_user(c, data + i))				return -EFAULT;            if (c == 'V')				expect_close = 42;		}        		tiny6410_wdt_feeddog();	}	return len;}static const struct file_operations tiny6410_wdt_fops = {	.owner		      = THIS_MODULE,    .open             = tiny6410_wdt_open,    .write		      = tiny6410_wdt_write,	.unlocked_ioctl	  = tiny6410_wdt_ioctl,	.release	      = tiny6410_wdt_release,};static struct miscdevice tiny6410_wdt_miscdev = {	.minor		= WATCHDOG_MINOR,	.name		= "watchdog",	.fops		= &tiny6410_wdt_fops,};static int tiny6410_wdt_drv_probe(struct platform_device *pdev){    struct resource *res;    int size, ret, started = 0;        /* 1. Get the IORESOURCE_MEM of the watchdog */    res = platform_get_resource(pdev, IORESOURCE_MEM, 0);    if (!res) {        dev_err(&pdev->dev, "no such IORESOURCE_MEM available!\n");        return -ENOENT;    }    /* 2. Request the memory region */    size = resource_size(res);    wdt_mem = request_mem_region(res->start, size, pdev->name);    if (!wdt_mem) {        dev_err(&pdev->dev, "failed to get memory region!\n");        return -EBUSY;    }        /* 3. ioremap */    wdt_va = ioremap(res->start, size);    if (!wdt_va) {        dev_err(&pdev->dev, "failed to ioremap wdt region!\n");        ret = -EINVAL;        goto err_request;    }    /* 4. Get the IORESOURCE_IRQ of the watchdog */    wdt_irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);    if (!wdt_irq) {                dev_err(&pdev->dev, "no such IORESOURCE_IRQ available!\n");        ret = -ENOENT;        goto err_ioremap;    }        /* 5. request_irq */    ret = request_irq(wdt_irq->start, tiny6410_wdt_irq, 0, pdev->name, pdev);    if (ret != 0) {        dev_err(&pdev->dev, "failed to request_irq!\n");        goto err_ioremap;    }    /* 5. Enable the clock of the watchdog timer */    wdt_clk = clk_get(&pdev->dev, "watchdog");	if (IS_ERR(wdt_clk)) {		dev_err(&pdev->dev, "failed to find watchdog clock source\n");		ret = PTR_ERR(wdt_clk);		goto err_requestirq;	}        clk_enable(wdt_clk);    /* 6. Setup the watchdog hardware config */	/* see if we can actually set the requested timeout value, and if	 * not, try the default value */	if (tiny6410_setup_wdt_config(timeout_val)) {		started = tiny6410_setup_wdt_config(					CONFIG_TINY6410_WATCHDOG_TIMEOUT_DEFAULT_VALUE);		if (started == 0)			dev_info(&pdev->dev,			   "timeout_val is out of range, default %d used\n",			       CONFIG_TINY6410_WATCHDOG_TIMEOUT_DEFAULT_VALUE);		else			dev_info(&pdev->dev, "default timeout value is out of range, "							"cannot start\n");	}        /* 7. misc_register */	ret = misc_register(&tiny6410_wdt_miscdev);	if (ret) {		dev_err(&pdev->dev, "cannot register miscdev on minor=%d (%d)\n",			WATCHDOG_MINOR, ret);		goto err_clk;	}    /* 8. Makesure the watchdog timer is stopped */    tiny6410_wdt_stop();    return 0;err_clk:    clk_disable(wdt_clk);    clk_put(wdt_clk);    err_requestirq:    free_irq(wdt_irq->start, pdev);    err_ioremap:    iounmap(wdt_va);    err_request:    release_resource(wdt_mem);    kfree(wdt_mem);        return ret;}
static int tiny6410_wdt_drv_remove(struct platform_device *pdev){    misc_deregister(&tiny6410_wdt_miscdev);    clk_disable(wdt_clk);    clk_put(wdt_clk);    wdt_clk = NULL;            free_irq(wdt_irq->start, pdev);    wdt_irq = NULL;    iounmap(wdt_va);    wdt_va = NULL;       release_resource(wdt_mem);    kfree(wdt_mem);    wdt_mem = NULL;    return 0;}
static struct platform_driver tiny6410_wdt_driver = {    .probe              = tiny6410_wdt_drv_probe,    .remove             = __devexit_p(tiny6410_wdt_drv_remove),    .driver             = {        .owner  = THIS_MODULE,        .name   = "tiny6410_wdt",    },};static int __init tiny6410_wdt_drv_init(void){    return platform_driver_register(&tiny6410_wdt_driver);}static void __exit tiny6410_wdt_drv_exit(void){    platform_driver_unregister(&tiny6410_wdt_driver);}
module_init(tiny6410_wdt_drv_init);module_exit(tiny6410_wdt_drv_exit);
MODULE_LICENSE("GPL");MODULE_AUTHOR("Pete&Charles <http://embeddedfansclub.taobao.com>");
